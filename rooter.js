// Generated by CoffeeScript 1.3.3
(function() {
  var hash, hashTimer, rooter,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  hash = {
    lastHash: null,
    listeners: [],
    listen: function(fn) {
      return rooter.hash.listeners.push(fn);
    },
    trigger: function(hash) {
      var fn, _i, _len, _ref;
      if (hash == null) {
        hash = rooter.hash.value();
      }
      rooter.hash.lastHash = hash;
      _ref = rooter.hash.listeners;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        fn = _ref[_i];
        fn(hash);
      }
    },
    value: function(h) {
      if (h) {
        window.location.hash = h;
      }
      hash = window.location.hash.replace('#', '');
      if (hash === "") {
        hash = "/";
      }
      return hash;
    }
  };

  hashTimer = {};

  __extends(hashTimer, hash);

  hashTimer.value = function(h) {
    if (h) {
      rooter.hash.lastHash = h;
      window.location.hash = h;
    }
    return window.location.hash.replace('#', '');
  };

  hashTimer.check = function() {
    var currHash;
    currHash = rooter.hash.value();
    if (currHash !== rooter.hash.lastHash) {
      rooter.hash.trigger(currHash);
    }
    setTimeout(rooter.hash.check, 100);
  };

  rooter = {
    lastMatch: null,
    routes: [],
    route: function(expr, fn) {
      var currHash, o, pattern;
      pattern = "^" + expr + "$";
      pattern = pattern.replace(/([?=,\/])/g, '\\$1').replace(/:([\w\d]+)/g, '([^/]*)');
      o = {
        route: expr,
        names: expr.match(/:([\w\d]+)/g),
        pattern: new RegExp(pattern),
        fn: fn
      };
      rooter.routes.push(o);
      currHash = rooter.hash.value();
      if (rooter.isMatch(currHash, o)) {
        rooter.triggerMatch(currHash, o);
      }
      return rooter;
    },
    isMatch: function(hash, r) {
      return r.pattern.exec(hash) != null;
    },
    triggerMatch: function(hash, r) {
      var args, idx, name, o, _i, _len, _ref;
      rooter.lastMatch = hash;
      o = {};
      if (r.names) {
        args = r.pattern.exec(hash).slice(1);
        _ref = r.names;
        for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
          name = _ref[idx];
          o[name.substring(1)] = args[idx];
        }
      }
      r.fn(o);
    },
    matches: function(hash) {
      var r, _i, _len, _ref, _results;
      _ref = rooter.routes;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        r = _ref[_i];
        if (rooter.isMatch(hash, r)) {
          _results.push(r);
        }
      }
      return _results;
    },
    test: function(hash) {
      var match, matches, _i, _len;
      matches = rooter.matches(hash);
      if (!(matches.length > 0)) {
        return;
      }
      for (_i = 0, _len = matches.length; _i < _len; _i++) {
        match = matches[_i];
        rooter.triggerMatch(hash, match);
      }
    }
  };

  if (typeof window.onhashchange !== 'undefined') {
    rooter.hash = hash;
    window.onhashchange = function() {
      return rooter.hash.trigger(rooter.hash.value());
    };
  } else {
    rooter.hash = hashTimer;
    setTimeout(rooter.hash.check, 100);
  }

  rooter.hash.listen(rooter.test);

  if (rooter.hash.check) {
    rooter.hash.check();
  }

  window.rooter = rooter;

}).call(this);
